
#include<cstdlib>
#include<iostream>
/********************************************************************************/
/********************************************************************************/
/*  Function to advect the volume of fluid field                                */
/*  method. 									*/
/*  										*/
/*  Programmer	: Duncan van der Heul       					*/
/*  Date	: 10-03-2013       						*/
/*  Update	:        							*/
/********************************************************************************/
/* Notes									*/
/* The volume of fluid field is advected using an operator splitting technique  */
/* that is explained in both Sander's thesis as in the papers of Sussman        */
/* and is first order accurate. This does not guarantee that the volume of      */
/* fluid value remains within the interval [0,1]. 	 			*/
/* Furthermore, it can occur that a cell is too large to represent a small      */
/* feature. This leads to cells with intermediate values of the volume of 	*/
/* fluid in cells that are NOT interface cells. Of course this can not be 	*/
/* allowed. Both effects:                                                       */
/* -cells that are overfilled or underdrained					*/
/* -cells that contain numerical vapor                                  e       */
/* Have to handled in a way that does not disturb the global mass conservation. */
/* level set fields.								*/
/********************************************************************************/
      void apply_volume_of_fluid_redistribution(
	    double ***volume_of_fluid, 				// volume of fluid field
	    double ***level_set_star, 				// level set field at new time level
								// after convection and reinitialization
								// not mass conserving
	    double ***level_set_new, 				// level set field at new time level
								// mass conserving
	    int number_primary_cells_i,				// number of primary (pressure) cells in x1 direction
	    int number_primary_cells_j,				// number of primary (pressure) cells in x2 direction
	    int number_primary_cells_k,				// number of primary (pressure) cells in x3 direction
	    double mesh_width_x1,				// grid spacing in x1 direction (uniform)
	    double mesh_width_x2,				// grid spacing in x2 direction (uniform)
	    double mesh_width_x3,				// grid spacing in x3 direction (uniform)
	    int maximum_number_mass_redistribution_iterations,  // number of iterations allowed to make
								// the volume of fluid field valid
								// these are the sweeps on the vof error
	    double volume_of_fluid_tolerance,			// tolerance on the value of the volume
								// of fluid value
	    double vof_2_level_set_tolerance,			// tolerance in the conversion from volume
								// of fluid value to level-set value
	    double lower_bound_derivatives,			// lower bound for the first partial derivatives
								// to consider it a limiting case of vanishing
								// partial derivatives
	    int number_vof_2_level_set_iterations,		// number of OUTER iterations in the conversion 
								// from volume of fluid to level-set
	    int number_iterations_ridder			// maximum number of iterations allowed in the
								// nonlinear root finding algorithm
	    )
      {
      void match_level_set_to_volume_of_fluid(				// compute a new level-set field
		 double ***level_set_not_mass_conserving, 		// that corresponds to given
		 double ***volume_of_fluid,				// volume of fluid field
		 double ***level_set_mass_conserving,			// using an existing level-set
		 int number_primary_cells_i, 				// field as a starting value
		 int number_primary_cells_j, 
		 int number_primary_cells_k,			
		 double volume_of_fluid_tolerance,		
		 double lower_bound_derivatives,		
		 int number_vof_2_level_set_iterations,		
		 int number_iterations_ridder,			
		 double vof_2_level_set_tolerance		
		);
      double ***double_Matrix2(int number_primary_cells_i,		// allocate memory for a three-
				int number_primary_cells_j, 		// dimensional array of doubles
				  int number_primary_cells_k);
      void free_double_Matrix2( 					// deallocate memory for a three
		double ***doubleMatrix2, int number_primary_cells_i,	// dimensional array of doubles
		int number_primary_cells_j);
      void copy_cell_centered_field(					// copy a source field
		 double ***source_field, 				// to a target field 
		 double ***target_field, 				
		 int number_primary_cells_i, int number_primary_cells_j,
		 int number_primary_cells_k);
      void match_level_set_to_volume_of_fluid(				// compute a new level-set field
		 double ***level_set_not_mass_conserving, 		// that corresponds to given
		 double ***volume_of_fluid,				// volume of fluid field
		 double ***level_set_mass_conserving,			// using an existing level-set
		 int number_primary_cells_i,                            // field as a starting value
		 int number_primary_cells_j, 
		 int number_primary_cells_k);                           // modify volume of fluid
      int modify_volume_of_fluid_values(				// values and count number
		double ***level_set, 				        // of cells with invalid		  
		double ***volume_of_fluid,			        // volume of fluid valuesluid_correction, 
		double ***volume_of_fluid_correction,			  
		double ***time_derivative_volume_of_fluid,			
		int number_primary_cells_i,			  
		int number_primary_cells_j,			  
		int number_primary_cells_k,			  
		double time_step_mass_redistribution,		    
		double volume_of_fluid_tolerance
		  );
      void apply_redistribution_volume_of_fluid_correction(   		// redistribute the error
		double ***level_set,                                  	// in the volume of fluid field                           		
		double ***volume_of_fluid,                              // to achieve a valid field                               	
		double ***volume_of_fluid_correction,
		double mesh_width_x1,			
		double mesh_width_x2,			
		double mesh_width_x3,			
		int maximum_number_mass_redistribution_iterations,
		int vof_2_level_set_tolerance
	   );
      int apply_volume_of_fluid_clipping(				// clip the values of		
		 double ***volume_of_fluid, 		                // the volume of fluid field                     	
		 int number_primary_cells_i,		                // to bring them in the correct
		 int number_primary_cells_j,		           	// interval [0,1]
		 int number_primary_cells_k,		
		 double volume_of_fluid_tolerance	
		
      );
      double ***volume_of_fluid_star;		// volume of fluid field, uncorrected
						// so with possible vapour cells and 
						// under/overfilled cells
      double ***volume_of_fluid_correction;	// correction to the volume of fluid field
						// to make it valid
      
      int number_cells_vof_out_of_bounds=100;	// number of control volumes where the volume of fluid
						// function is OUTSIDE the interval [0,1]
      int number_cells_numerical_vapor=100;		// number of control volumes where the volume of fluid
						// function is INSIDE the interval [0,1]
						// while the cell has 6 neighbours with the same sign:
						// the cell is NOT an interface cell
      int number_cells_invalid_volume_of_fluid
				      =200; 	// sum of number of vapour cells and number of cells
						// with the volume of fluid outside [0,1];
      int number_redistribution_attempts=2;	// number of attempts to achieve a
						// valid volume of fluid field
						// through the redistribution algorithm
      int index_redistribution_attempt=1;	// number of attempts to achieve a
						// valid volume of fluid field
						// through the redistribution algorithm
						
      /* allocate memory for the volume of fluid correction and the tentative */
      /* volume of fluid field 						      */
      
	volume_of_fluid_correction=double_Matrix2(number_primary_cells_i, 
						    number_primary_cells_j,
						      number_primary_cells_k);
	volume_of_fluid_star=double_Matrix2(number_primary_cells_i+2, 
						    number_primary_cells_j+2,
						      number_primary_cells_k+2);
      
      /*---start the update loop ---*/
      /* it is unclear to me why this should be attempted multiple times */
      /* but it is possible the changes can be locally that strong it is */
      /* necessary.							 */
      
	while(index_redistribution_attempt<=number_redistribution_attempts &&
	      number_cells_numerical_vapor>0 &&
		  number_cells_vof_out_of_bounds>0 )
	{
	  
      /* copy the original volume of fluid field to the star volume of fluid field */

	 copy_cell_centered_field(volume_of_fluid, volume_of_fluid_star, 				
		      number_primary_cells_i, number_primary_cells_j, number_primary_cells_k);
      
      /* apply clipping to the tentative volume of fluid field */
      
	  number_cells_vof_out_of_bounds=
	      apply_volume_of_fluid_clipping(volume_of_fluid_star, 
		    number_primary_cells_i, number_primary_cells_j, number_primary_cells_k,
		                  volume_of_fluid_tolerance);

      /* bring the level-set field in accordance with the clipped volume of fluid field */

	  match_level_set_to_volume_of_fluid(level_set_star, volume_of_fluid_star,
						     level_set_new,
				number_primary_cells_i, number_primary_cells_j, 
							    number_primary_cells_k,			
				  volume_of_fluid_tolerance, lower_bound_derivatives,		
				    number_vof_2_level_set_iterations, number_iterations_ridder,			
				      vof_2_level_set_tolerance);	
      
      /* modify the volume of fluid field: determine the error and the number of */
      /* invalid cells */
	    number_cells_invalid_volume_of_fluid=			// modify volume of fluid
		modify_volume_of_fluid_values(				// values and count number
		level_set_star, 				        // of cells with invalid		  
		volume_of_fluid,			        	// volume of fluid values 
		volume_of_fluid_correction,			  
		time_derivative_volume_of_f			
		number_primary_cells_i,			  
		number_primary_cells_j,			  
		number_primary_cells_k,			  
		time_step_mass_redistribution,		    
		volume_of_fluid_tolerance
		  );

      /* if necessary redistribute the volume of fluid correction */
      /* so we end up with a valid field 			  */
      
      
	  index_redistribution_attempt++;
	}
	
      /* if there are remaining invalid cells, apply the correction one more time */
      /* and bring the level-set field in accordance with the new volume of fluid */
      /* field 									  */
	if(number_cells_invalid_volume_of_fluid>0)
	{
	    number_cells_invalid_volume_of_fluid=			// modify volume of fluid
		modify_volume_of_fluid_values(				// values and count number
		level_set_star, 				        // of cells with invalid		  
		volume_of_fluid,			        	// volume of fluid values 
		volume_of_fluid_correction,			  
		time_derivative_volume_of_f			
		number_primary_cells_i,			  
		number_primary_cells_j,			  
		number_primary_cells_k,			  
		time_step_mass_redistribution,		    
		volume_of_fluid_tolerance
		  );

	    match_level_set_to_volume_of_fluid( 
		      level_set_star, volume_of_fluid, level_set_new, 
			number_primary_cells_i, 
			  number_primary_cells_j, number_primary_cells_k,			
				  volume_of_fluid_tolerance, lower_bound_derivatives,		
				    number_vof_2_level_set_iterations, number_iterations_ridder,			
				      vof_2_level_set_tolerance);
	}
	
	/* deallocate temporary storage */
	  
      free_double_Matrix2(volume_of_fluid_star, number_primary_cells_i+2, 
			          number_primary_cells_j+2);
      free_double_Matrix2(volume_of_fluid_correction, number_primary_cells_i,
				  number_primary_cells_j);
}
  
