class vector
{
public:
  double u1,u2,u3;
};
/********************************************************************************/
/********************************************************************************/
/*  Function to apply the pressure correction to the tentative velocity field   */
/*  										*/
/*  Programmer	: Duncan van der Heul       					*/
/*  Date	: 10-03-2013       						*/
/*  Update	:        							*/
/********************************************************************************/
/* Notes									*/
/* In the original implementation of Sander the subroutine contained both the   */
/* application of the pressure correction to the velocity field and the         */
/* computation of the momentum equation source terms. The latter is now         */
/* put in a separate function.                                                  */
/* Note that in all cases the PRESSURE is computed in the pressure correction   */
/* equation, not the pressure correction.                                       */
/* Currently we assume a Dirichlet boundary condition for all normal velocities.*/
/********************************************************************************/
  void apply_pressure_correction(
	    double ***level_set, 				// level-set field
	    double ***pressure,					// pressure field
	    double ***u_1_velocity_star, 	     		// velocity field at star time level x1 direction
	    double ***u_2_velocity_star, 	     		// velocity field at star time level x2 direction
	    double ***u_3_velocity_star,	     		// velocity field at star time level x3 direction
	    double ***surface_tension_body_force_x1,		// x1 component of the body force due to
								// CSF formulation of surface tension model
	    double ***surface_tension_body_force_x2,		// x2 component of the body force due to
								// CSF formulation of surface tension model
	    double ***surface_tension_body_force_x3,		// x3 component of the body force due to
								// CSF formulation of surface tension model
	    double ***momentum_source_term_u_1, 		// complete source term for the momentum equation
								// in x1 direction=(-p,1+ g_1 +F1)
	    double ***momentum_source_term_u_2, 		// complete source term for the momentum equation
								// in x2 direction=(-p,2+ g_2 +F2)
	    double ***momentum_source_term_u_3, 		// complete source term for the momentum equation
								// in x3 direction=(-p,3+ g_3 +F3)
	    int number_primary_cells_i,				// number of primary (pressure) cells in x1 direction
	    int number_primary_cells_j,				// number of primary (pressure) cells in x2 direction
	    int number_primary_cells_k,				// number of primary (pressure) cells in x3 direction
	    double mesh_width_x1,				// grid spacing in x1 direction (uniform)
	    double mesh_width_x2,				// grid spacing in x2 direction (uniform)
	    double mesh_width_x3,				// grid spacing in x3 direction (uniform)
	    double rho_plus_over_rho_minus,			// ratio of the densities of the two phases
	    double actual_time_step_navier_stokes, 		// actual time step for Navier-Stokes solution algorithm 
	    vector gravity					// gravitational acceleration vector 
       )
  {
	/* function definitions */
	
	    double compute_scaled_density(			// compute the density at a cell face
		double level_set_left, 				// based on the level-set values at the cell
		double level_set_right,				// centers of the two cells that share that face
		double rho_plus_over_rho_minus);
	    double density_cell_face_x1;			// density at cell face, normal in x1 direction
								// (location of u1 velocity)
	    double density_cell_face_x2;			// density at cell face, normal in x2 direction
								// (location of u2 velocity)					
 	    double density_cell_face_x3;			// density at cell face, normal in x3 direction
								// (location of u3 velocity)					
	    double one_over_dx1=    				// 1/(grid spacing in x1 direction) 
		1.0/(number_primary_cells_i);
	    double one_over_dx2=    				// 1/(grid spacing in x2 direction)
		1.0/(number_primary_cells_j);
	    double one_over_dx3=    				// 1/(grid spacing in x3 direction)^2 
		1.0/(number_primary_cells_k);
	    double level_set_left; 				// level-set value in left hand neighbouring cell
	    double level_set_right;				// level-set value in right hand neighbouring cell
	    int i_index, j_index, k_index;  			// local variables for loop indexing
    
	/* correct the velocity in the x1 direction */
	
      for(i_index=1;i_index<number_primary_cells_i;i_index++)
      {
	  for(j_index=1;j_index<number_primary_cells_j+1;j_index++)
	  {
	      for(k_index=1;k_index<number_primary_cells_k+1;k_index++)
	      {
		level_set_left =level_set[i_index  ][j_index][k_index];
		level_set_right=level_set[i_index+1][j_index][k_index];
		density_cell_face_x1=compute_scaled_density(
			      level_set_left, level_set_right, rho_plus_over_rho_minus);
		u_1_velocity_star[i_index][j_index][k_index]-=
		    actual_time_step_navier_stokes*(
		      one_over_dx1*(pressure[i_index+1][j_index][k_index]-
				      pressure[i_index][j_index][k_index])/density_cell_face_x1-
				      gravity.u1 - 
					surface_tension_body_force_x1[i_index][j_index][k_index]+
					momentum_source_term_u_1[i_index][j_index][k_index]);
	      }  
	  }  
      }  
      
 	/* correct the velocity in the x2 direction */
	
      for(i_index=1;i_index<number_primary_cells_i+1;i_index++)
      {
	  for(j_index=1;j_index<number_primary_cells_j+1;j_index++)
	  {
	      for(k_index=1;k_index<number_primary_cells_k+1;k_index++)
	      {
		level_set_left =level_set[i_index][j_index  ][k_index];
		level_set_right=level_set[i_index][j_index+1][k_index];
		density_cell_face_x2=compute_scaled_density(
			      level_set_left, level_set_right, rho_plus_over_rho_minus);
		u_2_velocity_star[i_index][j_index][k_index]-=
		    actual_time_step_navier_stokes*(
		      one_over_dx2*(pressure[i_index][j_index+1][k_index]-
				      pressure[i_index][j_index][k_index])/density_cell_face_x2-
				      gravity.u2 - 
					surface_tension_body_force_x2[i_index][j_index][k_index]+
					momentum_source_term_u_2[i_index][j_index][k_index]);
	      }  
	  }  
      }  
     
      
 	/* correct the velocity in the x3 direction */
	
      for(i_index=1;i_index<number_primary_cells_i+1;i_index++)
      {
	  for(j_index=1;j_index<number_primary_cells_j+1;j_index++)
	  {
	      for(k_index=1;k_index<number_primary_cells_k;k_index++)
	      {
		level_set_left =level_set[i_index][j_index][k_index  ];
		level_set_right=level_set[i_index][j_index][k_index+1];
		density_cell_face_x3=compute_scaled_density(
			      level_set_left, level_set_right, rho_plus_over_rho_minus);
		u_3_velocity_star[i_index][j_index][k_index]-=
		    actual_time_step_navier_stokes*(
		      one_over_dx3*(pressure[i_index][j_index][k_index+1]-
				      pressure[i_index][j_index][k_index])/density_cell_face_x3-
				      gravity.u3 - 
					surface_tension_body_force_x3[i_index][j_index][k_index]+
					momentum_source_term_u_3[i_index][j_index][k_index]);
	      }  
	  }  
      }  
      
  }

/*
C------------------------------
C  Update the velocity fields
C------------------------------
c      do k=1,kmax
c         do j=1,jmax
c            do i=1,imax
C   just copy them  all, this covers all boundary conditions

       do k=0,kmax+1
         do j=0,jmax+1
            do i=0,imax+1
            Uold(i,j,k)=Unew(i,j,k)
            Unew(i,j,k)=dUdt(i,j,k)
            Vold(i,j,k)=Vnew(i,j,k)
            Vnew(i,j,k)=dVdt(i,j,k)
            Wold(i,j,k)=Wnew(i,j,k)
            Wnew(i,j,k)=dWdt(i,j,k)
            enddo
        enddo
      enddo
C------------------------------
C  Update sx, sy and sz
C------------------------------
      if (DO_SX.ne.1) goto 111
      
      do k=1,kmax
        do j=1,jmax
          do i=1,imax-1
            call comp_rho(Phi(i,j,k), Phi(i+1,j,k), rhop_rhom, rho)
              sx(i,j,k) = -dxi * ( P(i+1,j,k)-P(i,j,k) )/rho
     .                    + gx + fx(i,j,k)
          enddo
	  sx(0,j,k) = 0.
	  sx(imax,j,k) = 0.
        enddo
      enddo
      do k=1,kmax
        do j=1,jmax-1
          do i=1,imax
            call comp_rho(Phi(i,j,k), Phi(i,j+1,k), rhop_rhom, rho)
              sy(i,j,k) = -dyi * ( P(i,j+1,k)-P(i,j,k) )/rho
     .                    + gy + fy(i,j,k)
          enddo
        enddo
        do i=1,imax
	  sy(i,0,k) = 0.
	  sy(i,jmax,k) = 0.
	end do
      enddo
      do j=1,jmax-1  
      end do
      do k=1,kmax-1
        do j=1,jmax
          do i=1,imax
            call comp_rho(Phi(i,j,k), Phi(i,j,k+1), rhop_rhom, rho)
              sz(i,j,k) = -dzi * ( P(i,j,k+1)-P(i,j,k) )/rho
     .                    + gz + fz(i,j,k)
          enddo
        enddo
        do j=1,jmax
          do i=1,imax
	    sz(i,j,0) = 0.
	    sz(i,j,kmax) = 0.
	  end do
        enddo
      enddo
      
  111 continue
      
      return
      end
*/    