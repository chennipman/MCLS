#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<math.h>
enum variable{velocity_u1, velocity_u2, velocity_u3, level_set, pressure};
enum boundary_conditions_type{dirichlet, neumann, periodic};
enum boundary_conditions_rule{constant, function};
enum cell_centerings{cell_centered, vertex_centered};


class boundary_variable
{
public:
  variable variable_name;
  boundary_conditions_type boundary_condition_type;
  boundary_conditions_rule boundary_condition_rule;
  cell_centerings cell_centering;
  double boundary_condition_value;
  boundary_variable(variable varname, boundary_conditions_type bound_type,
				     boundary_conditions_rule bound_rule,
				     cell_centerings  cell_cent,
					double bound_value );
  boundary_variable(variable varname);
};

class boundary_face
{
public:
    boundary_variable boundary_variables[5];
    boundary_face(void);
   
};
        
class vector
{
public:
  double u1,u2,u3;
};

/********************************************************************************/
/*  Function to initialize the flow field                                       */
/*  										*/
/*  Programmer	: Duncan van der Heul       					*/
/*  Date	: 10-03-2013       						*/
/*  Update	:        							*/
/********************************************************************************/
/* Notes									*/
/* For the moment the whole solution is initially set to zero, this should be   */
/* extended to more advanced cases, e.g. a parabolic profile etc.		*/
/********************************************************************************/
void initialize_flow_field(
      double ***u_1_velocity_new, 			// velocity field at new time level x1 direction
      double ***u_2_velocity_new, 			// velocity field at new time level x2 direction
      double ***u_3_velocity_new,			// velocity field at new time level x3 direction
      double ***u_1_velocity_old, 			// velocity field at old time level x1 direction
      double ***u_2_velocity_old, 			// velocity field at old time level x2 direction
      double ***u_3_velocity_old,			// velocity field at old time level x3 direction
      double ***pressure,				// pressure
      boundary_face boundary_faces[6],			// array with all the information
							// for the boundary conditions 
      double mesh_width_x1,				// grid spacing in x1 direction (uniform)
      double mesh_width_x2,				// grid spacing in x2 direction (uniform)
      double mesh_width_x3,				// grid spacing in x3 direction (uniform)
      int number_primary_cells_i,			// number of primary (pressure) cells in x1 direction
      int number_primary_cells_j,			// number of primary (pressure) cells in x2 direction
      int number_primary_cells_k,			// number of primary (pressure) cells in x3 direction
      vector initial_velocity				// initial velocity field at t=0
	)
   /* function definitions */
    {

       void set_constant_matrix2(
	int first_dimension,				// number of elements in first dimension
	int second_dimension,				// number of elements in second dimension
	int third_dimension,				// number of elements in third dimension
	double ***matrix2_to_set,			// the name of the array that has to be set
	double constant_value				// the constant value the vector has to be set to
     );
      void apply_boundary_conditions_velocity(         // apply boundary conditions to velocity field
	  boundary_face boundary_faces[6],		
	  double ***u_1_velocity, 			
	  double ***u_2_velocity, 			
	  double ***u_3_velocity, 			
	  double mesh_width_x1,				
	  double mesh_width_x2,				
	  double mesh_width_x3,				
	  int number_primary_cells_i,			
	  int number_primary_cells_j,			
	  int number_primary_cells_k			
     );
      
       

  
    /* initialize the velocity field */
    
      /* old time level */
    
      set_constant_matrix2(number_primary_cells_i+1, number_primary_cells_j+2, 
			    number_primary_cells_k+2, u_1_velocity_new, initial_velocity.u1);
      set_constant_matrix2(number_primary_cells_i+2, number_primary_cells_j+1, 
			    number_primary_cells_k+2, u_2_velocity_new, initial_velocity.u2);
      set_constant_matrix2(number_primary_cells_i+2, number_primary_cells_j+2, 
			    number_primary_cells_k+1, u_3_velocity_new, initial_velocity.u3);
      

      /* new time level */
       
      set_constant_matrix2(number_primary_cells_i+1, number_primary_cells_j+2, 
			    number_primary_cells_k+2, u_1_velocity_old, initial_velocity.u1);
      set_constant_matrix2(number_primary_cells_i+2, number_primary_cells_j+1, 
			    number_primary_cells_k+2, u_2_velocity_old, initial_velocity.u2);
      set_constant_matrix2(number_primary_cells_i+2, number_primary_cells_j+2, 
			    number_primary_cells_k+1, u_3_velocity_old, initial_velocity.u3);
      

      
      /* apply the boundary conditions to the velocity field */
    
      /* new time level */
       
      apply_boundary_conditions_velocity(boundary_faces,		
					  u_1_velocity_new, u_2_velocity_new, u_3_velocity_new, 			
					    mesh_width_x1, mesh_width_x2, mesh_width_x3,				
					      number_primary_cells_i, number_primary_cells_j,number_primary_cells_k);

      /* old time level */
       
      apply_boundary_conditions_velocity(boundary_faces,		
					  u_1_velocity_old, u_2_velocity_old, u_3_velocity_old, 			
					    mesh_width_x1, mesh_width_x2, mesh_width_x3,				
					      number_primary_cells_i, number_primary_cells_j,number_primary_cells_k);
    
    /* intialize the pressure */
    
      set_constant_matrix2(number_primary_cells_i+2, number_primary_cells_j+2, 
			    number_primary_cells_k+2, pressure, 0.0);
      
    }