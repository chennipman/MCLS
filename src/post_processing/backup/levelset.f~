C-------------------------------------------------------------------------------
C  Update of Phi
C
C    Phi	Level-Set function at previous time-step (global)
C    VOF	VOF       function at previous time-step (global)
C    Phi_ls	Level-Set function after Level-Set advection and re-init.
C    Phi_dum	dummy
C-------------------------------------------------------------------------------
      
      subroutine update_levelset(fx, fy, fz, dt_st, do_reinit)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real, dimension(:,:,:), allocatable :: Phi_ls, Phi_dum
      
      real fx(0:imax,1:jmax,1:kmax), fy(1:imax,0:jmax,1:kmax),
     1     fz(1:imax,1:jmax,0:kmax)
      real dt_st
      
      integer do_reinit
      
      integer iter, idum
      
      real res, rdum
      
      real time1, time2, time3, time4
      
      allocate(Phi_ls(1-TWO:imax+TWO,1-TWO:jmax+TWO,1-TWO:kmax+TWO))
      allocate(Phi_dum(1-TWO:imax+TWO,1-TWO:jmax+TWO,1-TWO:kmax+TWO))
      
      call wall_clock_time(time1)
      
      call advect_Phi(Phi_dum)
      
      call wall_clock_time(time2)
      
      if (REINIT_ORDER.LE.1)  then
        if (do_reinit.ne.0) then
	  call reinit(Phi_dum, REINIT_MAXRES, -1000, REINIT_BANDWITH,
     1                Phi_ls, iter, res)
C        call reinit_new(Phi_dum, VOF, REINIT_MAXRES, 1000,
C     1              Phi_ls, iter, res)
        else        
          call copy_phi(Phi_dum, Phi_ls, TWO)
        end if
      else
        call reinit_ENO(imax, jmax, kmax, dxi, dyi, dzi,
     1    TWO, REINIT_CFL, REINIT_MAXRES, 0, 1000, REINIT_ORDER, 
     2    REINIT_BANDWITH, Phi_dum,Phi_ls,iter,res)
      end if
      
      call wall_clock_time(time3)

C-------------------------------------------------------------------------------
C  Update of Psi and correct Phi
C-------------------------------------------------------------------------------
 
      call update_VOF(Phi_ls)
        
      call wall_clock_time(time4)
      
C-------------------------------------------------------------------------------
C  surface tension
C    11-01-08: compute curv based on Phi after mass correction
C-------------------------------------------------------------------------------
C      call comp_st(Phi_dum, VOF, dxi, dyi, dzi, sigma, rhop_rhom,
C     1             fx, fy, fz, dt_st)
      call comp_st(Phi, VOF, dxi, dyi, dzi, sigma, rhop_rhom,
     1             fx, fy, fz, dt_st)
      
      if (LEVELSET_TIMINGS .eq. 'yes') then
        write(6,"(A14,F13.5,A)") 'advect:', time2-time1, ' sec.'
        if (do_reinit.ne.0) then
	  write(6,"(A14,F13.5,A,I13,A5,E13.5)")
     1	    'reinit:', time3-time2, ' sec.', iter, 'iter', res
        end if
	write(6,"(A14,F13.5,A)") 'update VOF:', time4-time3, ' sec.'
      end if
C
  100 continue     
  
      deallocate(Phi_ls)
      deallocate(Phi_dum) 
      
      return
      end

C-------------------------------------------------------------------------------
C  Initialization of Phi and Psi
C  Bubbles lie at (x0,y0,z0), (x1,y1,z1) with radii abs(R0) and abs(R1)
C-------------------------------------------------------------------------------

      subroutine init_levelset
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'

      real, dimension(:,:,:), allocatable :: Dx, Dy, Dz, Phi_r, eps

      real x,y,z, Phi1
      real alpha
      real t,r,g,h,mindist
      real dist1, dist2, dist3, Ell
      
      integer iter
      
      real res

      real num_mod
      
      allocate(Dx(0:i1,0:j1,0:k1))
      allocate(Dy(0:i1,0:j1,0:k1))
      allocate(Dz(0:i1,0:j1,0:k1))
      allocate(Phi_r(1-TWO:imax+TWO,1-TWO:jmax+TWO,1-TWO:kmax+TWO))

      allocate(eps(0:i1,0:j1,0:k1))

      do k=1,kmax
        z = (k-0.5)/dzi
        do j=1,jmax
          y = (j-0.5)/dyi
          do i=1,imax
            x = (i-0.5)/dxi

	    if (INIT_GEOM.eq.'cappil') then
	      mindist = 100.
	      do g=0,500
		t = g/500.
		do r = 0,100
		  dist1 = (x-t)**2
		  dist2 = (y-5.*r/(100.*imax))**2
		  dist3 = (z-(0.5*LZ0+0.01*cos(2.*PI*t)))**2
		  mindist = min(mindist,sqrt(dist1+dist2+dist3))
		enddo
	      enddo

	      if (z.lt.0.5*LZ0+0.01*cos(2.*PI*x)) then
		Phi(i,j,k) = -mindist
	      else 
		Phi(i,j,k) = mindist
	      endif
	    

	    else if (INIT_GEOM.eq.'bubble') then	! Spherical bubble case
	    	    
C 	    First define phi throughout the domain with respect to the bubble.
C	    Inside the bubble is first assumed positive, i.e. phi(i,j,k) = abs(R0) - ||x - x0||_2.

	      Phi(i,j,k) = abs(R0) - ((x-x0)**2. + (y-y0)**2. +	! Bubble 0
     1                         (z-z0)**2.)**0.5
	    
	      Phi1       = abs(R1) - ((x-x1)**2. + (y-y1)**2. +	! Bubble 1
     1                         (z-z1)**2.)**0.5
     
C	   Depending on the size of the two bubbles, make sure phi is the smallest distance.

	      if (abs(Phi(i,j,k)).gt.abs(Phi1)) Phi(i,j,k) = Phi1

C	   Introduce the difference between bubble and droplet: negative R0 is bubble, positive 
C	   R0 is droplet. For bubble, phi < 0 inside and for droplet, phi > 0 inside.
	    
              if ((R0.lt.0).or.(R1.lt.0)) Phi(i,j,k) = -Phi(i,j,k)	! change to phi < 0 inside bubble
  	      Phi1 = Z2-z						! Phi1 = distance to surface interface (can be negative)
	      if (abs(Phi(i,j,k)).gt.abs(Phi1)) Phi(i,j,k) = Phi1	! Above/under the surface, the shortest distance does not depend on the sphere anymore but on the surface only
	    
	    else if (INIT_GEOM.eq.'ellips') then	! Ellipsoid case, no free surface

	      mindist = 100.

	      do g=0,100		! = u
		t = -PI/2. + g*PI/100.
		do h=0,200	! = v
		  r = -PI + 2.*h*PI/200.
		  dist1 = (x-x0-a0*cos(t)*cos(r))**2.
		  dist2 = (y-y0-b0*cos(t)*sin(r))**2.
		  dist3 = (z-z0-c0*sin(t))**2.
		  mindist = min(mindist,sqrt(dist1+dist2+dist3))
		enddo
	      enddo

	      Phi(i,j,k) = mindist
	      
	      Ell = ((x-x0)/a0)**2. + ((y-y0)/b0)**2. + ((z-z0)/c0)**2.
	      if (Ell.lt.1.) then
		Phi(i,j,k) = -Phi(i,j,k)
	      endif
    
	    else 
	      write(6,"(a)") 'Invalid choice of geometry'
	      stop
	    endif
	  end do
	end do
      end do

C     Boundary conditions for the level set function.      
C     Neumann is currently used.
      
      call bound_levelset(Phi, TWO)

C     Re-initialize the level set function.

      call reinit(Phi, REINIT_MAXRES, -1000, REINIT_BANDWITH,
     1              Phi_r, iter, res)

C     Copy the level set function: Phi becomes equal to Phi_r.

      call copy_Phi(Phi_r, Phi, TWO)

C     Calculate the central differences of the level set.
C     Dx = 0.5 * (phi_i+1 - phi_i)
C     Dy = 0.5 * (phi_j+1 - phi_j)
C     Dz = 0.5 * (phi_k+1 - phi_k)

      call comp_diff_Phi(Phi, Dx, Dy, Dz)

C     Compute the value of the VOF function Psi in every cell.

      call compute_Psi(Phi, Dx, Dy, Dz, VOF)

C     Compute the mass by adding all VOF value of the grid.
C     Mass = sum (VOF) * dx * dy * dz.
C     (Actually this is a measure of volume).

      call comp_mass(VOF, mass0)

      deallocate(Dx)
      deallocate(Dy)
      deallocate(Dz)

      deallocate(eps)

      return
      end

C-------------------------------------------------------------------------------
C  Apply boundary conditions for the level set function.
C  'num' gives the number of boundary layers.
C    x: Neumann
C    y: Neumann
C    z: Neumann
C-------------------------------------------------------------------------------
      
      subroutine bound_levelset(var, num)

      implicit none
      include 'param.txt'

      integer num	
      real var(1-num:imax+num,1-num:jmax+num,1-num:kmax+num)
      integer indx

C--------------
C  x: Neumann
C--------------
      do k=1-num,kmax+num
        do j=1-num,jmax+num
	  do indx=1,num
	    var(1   -indx,j,k) = var(       indx,j,k)	! phi_0 = phi_1 (ONE) and phi_-1 = phi_2 (TWO)
	    var(imax+indx,j,k) = var(imax+1-indx,j,k)	! phi_N = phi_N+1 (ONE) and phi_N+2 = phi_N-1 (TWO)
	  end do
	end do
      end do

C--------------
C  y: Neumann
C--------------
      do k=1-num,kmax+num
        do indx=1,num
          do i=1-num,imax+num
	    var(i,1   -indx,k) = var(i,       indx,k)	! phi_0 = phi_1 (ONE) and phi_-1 = phi_2 (TWO)
	    var(i,jmax+indx,k) = var(i,jmax+1-indx,k)	! phi_N = phi_N+1 (ONE) and phi_N+2 = phi_N-1 (TWO)
	  end do
	end do
      end do

C---------------
CC  z: Neumann
C---------------
      do indx=1,num
        do j=1-num,jmax+num
          do i=1-num,imax+num
	   var(i,j,1   -indx) = var(i,j,indx)		! phi_0 = phi_1 (ONE) and phi_-1 = phi_2 (TWO)
	   var(i,j,kmax+indx) = var(i,j,kmax+1-indx)	! phi_N = phi_N+1 (ONE) and phi_N+2 = phi_N-1 (TWO)
	  end do
	end do
      end do
      
      return
      end

C-------------------------------------------------------------------------------
C  First-order advection of Phi -> Phi_new
C-------------------------------------------------------------------------------
     
      subroutine advect_Phi(Phi_new)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real Phi_new(1-TWO:imax+TWO,1-TWO:jmax+TWO,1-TWO:kmax+TWO)
      
      real vel, flux
      
C  set Phi_new = Phi

      call copy_Phi(Phi, Phi_new, TWO)

C  x-fluxes

      do k=1,kmax    
        do j=1,jmax
	  do i=0,imax
	    vel = Unew(i,j,k)
	    call comp_flux(vel,Phi(i,j,k),Phi(i+1,j,k),flux)
	    flux = flux * Dt * dxi
	    Phi_new(i,  j,k) = Phi_new(i,  j,k) - flux 
	    Phi_new(i+1,j,k) = Phi_new(i+1,j,k) + flux
	  end do
        end do
      end do

C  y-fluxes

      do k=1,kmax   
	do j=0,jmax
          do i=1,imax
	    vel = Vnew(i,j,k)
	    call comp_flux(vel,Phi(i,j,k),Phi(i,j+1,k),flux)
	    flux = flux * Dt * dyi
	    Phi_new(i,j,  k) = Phi_new(i,j,  k) - flux 
	    Phi_new(i,j+1,k) = Phi_new(i,j+1,k) + flux
	  end do
        end do
      end do

C  z-fluxes

      do k=0,kmax
        do j=1,jmax   
          do i=1,imax
	    vel = Wnew(i,j,k)
	    call comp_flux(vel,Phi(i,j,k),Phi(i,j,k+1),flux)
	    flux = flux * Dt * dzi
	    Phi_new(i,j,k  ) = Phi_new(i,j,k  ) - flux 
	    Phi_new(i,j,k+1) = Phi_new(i,j,k+1) + flux
	  end do
        end do
      end do

C  Apply boundary conditions for Phi

      call bound_levelset(Phi_new, TWO)
      
      return
      end

C-------------------------------------------------------------------------------
C  Upwind flux for Phi
C-------------------------------------------------------------------------------

      subroutine comp_flux(vel, PhiL, PhiR, flux)
      
      implicit none
      real vel, PhiL, PhiR, flux
      
      if (vel .gt. 0) then
        flux = PhiL * vel
      else
        if (vel .lt. 0) then
          flux = PhiR * vel
        else
          flux = 0.5*(PhiL + PhiR) * vel
        end if
      end if
      
      return
      end

C-------------------------------------------------------------------------------
C  Copy Phi_in to Phi_out: Phi_out becomes Phi_in
C  'num' is the number of boundary layers	
C-------------------------------------------------------------------------------

      subroutine copy_Phi(Phi_in, Phi_out, num)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common_ls.txt'
      
      integer num	! number of boundary layers
      
      real Phi_in(1-num:imax+num,1-num:jmax+num,1-num:kmax+num)
      real Phi_out(1-num:imax+num,1-num:jmax+num,1-num:kmax+num)
      
      do k=1-num,kmax+num
        do j=1-num,jmax+num
          do i=1-num,imax+num
	    Phi_out(i,j,k) = Phi_in(i,j,k)
	  end do
	end do
      end do
      
      return
      end

C-------------------------------------------------------------------------------
C  Tecplot / Paraview output
C  (Tecplot output is suppressed).
C-------------------------------------------------------------------------------
      
      subroutine tecplot(istep, isander, time, tsander, Dtsander)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      integer istep, isander
      real    time, tsander, Dtsander
      real    mass

      real    Lx, x
      
      real lvel(0:2,3), pjump, c(6)
      
      character*128 FNAM

      Lx = imax/dxi;

C-------------------------
C  write Level-Set and VOF
C-------------------------

      if (time .gt. tsander) then
        tsander = tsander + Dtsander

C        goto 1234	! Skips tecplot output

        write(FNAM, "('phi_', I0, '.dat')") isander
        open (24,file=FNAM)
        write(24,"(A)") 'VARIABLES = x, y, z, Phi, u, v, w, p'
        write(24,"(A,I5,A,I5,A,I5,A,I0,A)")
     1    'ZONE I=', imax, ', J=', jmax, ', K=', kmax,
     2    ', T = " ZONE ', isander, '"'
        do k=1,kmax
          do j=1,jmax
	    do i=1,imax
	      x = (i-0.5)/dxi
	      write(24,"(8E15.5)")
     1		x,
     2  	(j-0.5)/dyi,
     3  	(k-0.5)/dzi,
     4  	Phi(i,j,k),
     7  	0.5*(Unew(i-1,j,k) + Unew(i,j,k)),
     8  	0.5*(Vnew(i,j-1,k) + Vnew(i,j,k)),
     9  	0.5*(Wnew(i,j,k-1) + Wnew(i,j,k)), p(i,j,k)
	    enddo
          enddo
        enddo
        close(24)

 1234   continue
C
C        call vtk(isander, time)
C
        isander = isander + 1
      endif

C----------------------------------------
C  write mass
C----------------------------------------

      call comp_l(lvel)
      call comp_pjump(pjump)
      call comp_c(c)
      if (isander.eq.1) then
        open(123,file='mass.dat')
          write(123,"(A,$)") 'VARIABLES=i, t, mass, ''|mass/mass0-1|'''
          write(123,"(A,$)") ', L_0(u), L_1(u), L_2(u)'
          write(123,"(A,$)") ', L_0(v), L_1(v), L_2(v)'
          write(123,"(A)") ', L_0(w), L_1(w), L_2(w), pjump'
          write(123,"(I, 3E15.5, $)") 0, 0., mass0, 0.
          write(123,"(10E15.5)") lvel, pjump
        close(123)
C	
        open(124,file='post.dat')
        write(124,"(A,$)")'VARIABLES = isander, vol, xc, yc,'
        write(124, "(A)") 'zc, uc, vc, wc, t'
        write(124,"(I5,8E15.5)") isander, mass, c, time
        close(124)
      else
        call comp_mass(VOF, mass)
C	open(123,file='mass.dat',status='append')
	open(123,file='mass.dat',position='append')
        write(123,"(I, 3E15.5,$)") istep, time, mass, abs(mass/mass0-1)
          write(123,"(10E15.5)") lvel, pjump
	close(123)
C	
        open(124,file='post.dat',position='append')
        write(124,"(I5,8E15.5)") isander, mass, c, time
        close(124)
      end if

      return
      end

C-------------------------------------------------------------------------------
C  Write data
C-------------------------------------------------------------------------------

      subroutine write_data(FNAM)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real  dum
      
      character*128 FNAM

      open (24,file=FNAM)
      do k=0,k1
        do j=0,j1
          do i=0,i1
            write(24,"(8E15.5)") Phi(i,j,k), VOF(i,j,k),
     1        Unew(i,j,k), Vnew(i,j,k), Wnew(i,j,k),
     2        Uold(i,j,k), Vold(i,j,k), Wold(i,j,k)
          enddo
        enddo
      enddo

      return
      end

C-------------------------------------------------------------------------------
C  Read data
C-------------------------------------------------------------------------------

      subroutine read_data_old(FNAM)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real  dum
      
      character*128 FNAM

      open (24,file=FNAM)
      do k=0,k1
        do j=0,j1
          do i=0,i1
            read(24,*) Phi(i,j,k), VOF(i,j,k),
     1        Unew(i,j,k), Vnew(i,j,k), Wnew(i,j,k),
     2        Uold(i,j,k), Vold(i,j,k), Wold(i,j,k)
          enddo
        enddo
      enddo

      return
      end

C-------------------------------------------------------------------------------
C  Read data
C-------------------------------------------------------------------------------

      subroutine read_data(isander)
      implicit none
      
      integer isander
      
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real dum
C      real udum(1:i1,1:jmax,1:kmax), vdum(1:imax,1:j1,1:kmax),
C     1     wdum(1:imax,1:jmax,1:k1)
      
      real, dimension(:,:,:), allocatable :: udum, vdum, wdum
      
      character*128 FNAM
      
      allocate(udum(1:i1,1:jmax,1:kmax))
      allocate(vdum(1:imax,1:j1,1:kmax))
      allocate(wdum(1:imax,1:jmax,1:k1))

      write(FNAM, "('phi_', I0, '.dat')") isander
      
      open(24,file=FNAM)
      read(24,*)
      read(24,*)
      do k=1,kmax
        do j=1,jmax
          do i=1,imax
            read(24,*) dum, dum, dum, Phi(i,j,k),
     1        udum(i,j,k), vdum(i,j,k), wdum(i,j,k), p(i,j,k)
          enddo
        enddo
      enddo

      close(24)
      
      do k=1,kmax
	do j=1,jmax
	  do i=1,imax
	    Unew(i,j,k) = 0.5*(udum(i,j,k) + udum(i+1,j,k))
	    Vnew(i,j,k) = 0.5*(vdum(i,j,k) + vdum(i,j+1,k))
	    Wnew(i,j,k) = 0.5*(wdum(i,j,k) + wdum(i,j,k+1))
	  end do
	end do
      end do
      
      call bound(Unew,Vnew,Wnew)
      call bound_levelset(Phi, TWO)
      
      deallocate(udum)
      deallocate(vdum)
      deallocate(wdum)

      return
      end

C-------------------------------------------------------------------------------
C  Read data
C-------------------------------------------------------------------------------

      subroutine read_data_vtk(isander)
      implicit none
      
      integer isander
      
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real dum
C      real udum(1:i1,1:jmax,1:kmax), vdum(1:imax,1:j1,1:kmax),
C     1     wdum(1:imax,1:jmax,1:k1)
      
      real, dimension(:,:,:), allocatable :: udum, vdum, wdum
      
      character*128 FNAM
      
      allocate(udum(1:i1,1:jmax,1:kmax))
      allocate(vdum(1:imax,1:j1,1:kmax))
      allocate(wdum(1:imax,1:jmax,1:k1))

      write(FNAM, "('phi_', I0, '.vtk')") isander
      
      open(24,file=FNAM)
      
      do i=1,10
        read(24,*)
      end do
      
      do k=1,kmax
        do j=1,jmax
          do i=1,imax
            read(24,*) Phi(i,j,k)
            p(i,j,k) = 0.
          enddo
        enddo
      enddo
      
      read(24,*)
      
      do k=1,kmax
        do j=1,jmax
          do i=1,imax
            read(24,*) udum(i,j,k), vdum(i,j,k), wdum(i,j,k)
          enddo
        enddo
      enddo

      close(24)
      
      do k=1,kmax
	do j=1,jmax
	  do i=1,imax
	    Unew(i,j,k) = 0.5*(udum(i,j,k) + udum(i+1,j,k))
	    Vnew(i,j,k) = 0.5*(vdum(i,j,k) + vdum(i,j+1,k))
	    Wnew(i,j,k) = 0.5*(wdum(i,j,k) + wdum(i,j,k+1))
	  end do
	end do
      end do
      
      call bound(Unew,Vnew,Wnew)
      call bound_levelset(Phi, TWO)
      
      deallocate(udum)
      deallocate(vdum)
      deallocate(wdum)

      return
      end

C-------------------------------------------------------------------------------
C  Compute norms of u, v and w
C  (ivel,norm)
C-------------------------------------------------------------------------------
   
      subroutine comp_l(vel_l)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real vel_l(0:2,3)
      
      real dum1, dum2, dum0, fnum
      
C--------------------------
C  In x-direction
C--------------------------
      dum0 = 0.
      dum1 = 0.
      dum2 = 0.
      fnum = 1./(i1*jmax*kmax)
      do k=1,kmax
        do j=1,jmax
          do i=1,i1
	    dum0 = max(dum0,abs(unew(i,j,k)))	
	    dum1 = dum1 + abs(unew(i,j,k))	
	    dum2 = dum2 + unew(i,j,k)**2	
          end do
        end do
      end do
      vel_l(0,1) = dum0			! ||u||_{infty}
      vel_l(1,1) = dum1 * fnum		! ||u||_1
      vel_l(2,1) = sqrt(dum2 * fnum)	! ||u||_2

C--------------------------
C  In y-direction
C--------------------------
      dum0 = 0.
      dum1 = 0.
      dum2 = 0.
      fnum = 1./(imax*j1*kmax)
      do k=1,kmax
        do j=1,j1
          do i=1,imax
	    dum0 = max(dum0,abs(vnew(i,j,k)))
	    dum1 = dum1 + abs(vnew(i,j,k))
	    dum2 = dum2 + vnew(i,j,k)**2
          end do
        end do
      end do
      vel_l(0,2) = dum0			! ||v||_{infty}
      vel_l(1,2) = dum1 * fnum		! ||v||_1
      vel_l(2,2) = sqrt(dum2 * fnum)	! ||v||_2

C--------------------------
C  In z-direction
C--------------------------
      dum0 = 0.
      dum1 = 0.
      dum2 = 0.
      fnum = 1./(imax*jmax*k1)
      do k=1,k1
        do j=1,jmax
          do i=1,imax
	    dum0 = max(dum0,abs(wnew(i,j,k)))
	    dum1 = dum1 + abs(wnew(i,j,k))
	    dum2 = dum2 + wnew(i,j,k)**2
          end do
        end do
      end do
      vel_l(0,3) = dum0			! ||w||_{infty}
      vel_l(1,3) = dum1 * fnum		! ||w||_1
      vel_l(2,3) = sqrt(dum2 * fnum)	! ||w||_2
      
      return
      end

C-------------------------------------------------------------------------------
C  Compute jump in pressure 
C  Averaged by VOF values
C-------------------------------------------------------------------------------

      subroutine comp_pjump(pjump)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real pjump
      
      real vol0, vol1, p0, p1, dvol
      
      vol0 = 0.
      vol1 = 0.
      p0 = 0.
      p1 = 0.
      dvol = 1./(dxi*dyi*dzi)		! dvol = dx * dy * dz
      do k=1,kmax
        do j=1,jmax
          do i=1,imax
	    vol0 = vol0 +            (1.-VOF(i,j,k)) * dvol
	    vol1 = vol1 +                VOF(i,j,k)  * dvol
	    p0   =   p0 + p(i,j,k) * (1.-VOF(i,j,k)) * dvol
	    p1   =   p1 + p(i,j,k) *     VOF(i,j,k)  * dvol
          end do
        end do
      end do
      p0 = p0/vol0
      p1 = p1/vol1
      pjump = p1-p0
      
      return
      end

C-------------------------------------------------------------------------------
C  Calculate volume-averaged velocities and positions.
C-------------------------------------------------------------------------------
      
      subroutine comp_c(c)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      real c(6)
      
      real x, y, z, xc, yc, zc, uc, vc, wc
      real vol, fvol, psi0
      
      xc = 0.
      yc = 0.
      zc = 0.
      uc = 0.
      vc = 0.
      wc = 0.
      vol = 0.
      if ((R0.lt.0).or.(R1.lt.0)) then		! For bubbles
        do k=1,kmax
          z = (k-0.5)/dzi
          if (z.lt.Z2) then
            do j=1,jmax
              y = (j-0.5)/dyi
	      do i=1,imax
                x = (i-0.5)/dxi
                psi0 = 1. - VOF(i,j,k) 
                uc = uc + 0.5*(unew(i-1,j,k)+unew(i,j,k)) * psi0
                vc = vc + 0.5*(vnew(i,j-1,k)+vnew(i,j,k)) * psi0
                wc = wc + 0.5*(wnew(i,j,k-1)+wnew(i,j,k)) * psi0
                xc = xc + x * psi0
                yc = yc + y * psi0
                zc = zc + z * psi0
                vol = vol + psi0
	      end do
	    end do
          end if
        end do
      else
        do k=1,kmax
          z = (k-0.5)/dzi
          if (z.gt.Z2) then
            do j=1,jmax
              y = (j-0.5)/dyi
	      do i=1,imax
                x = (i-0.5)/dxi
                psi0 = VOF(i,j,k) 
                uc = uc + 0.5*(unew(i-1,j,k)+unew(i,j,k)) * psi0
                vc = vc + 0.5*(vnew(i,j-1,k)+vnew(i,j,k)) * psi0
                wc = wc + 0.5*(wnew(i,j,k-1)+wnew(i,j,k)) * psi0
                xc = xc + x * psi0
                yc = yc + y * psi0
                zc = zc + z * psi0
                vol = vol + psi0
	      end do
	    end do
          end if
        end do
      end if

      if (vol.gt.0.) then
        fvol = 1./vol
        xc = xc * fvol
        yc = yc * fvol
        zc = zc * fvol
        uc = uc * fvol
        vc = vc * fvol
        wc = wc * fvol
      end if
      
      c(1) = xc
      c(2) = yc
      c(3) = zc
      c(4) = uc
      c(5) = vc
      c(6) = wc
      
      return
      end

C-------------------------------------------------------------------------------
C  Write .vtk output
C  (Modified by guido).
C-------------------------------------------------------------------------------
      
      subroutine vtk(isander, time)
      implicit none
      include 'param.txt'
      include 'param_ls.txt'
      include 'common.txt'
      include 'common_ls.txt'
      
      integer istep, isander
      real    time, tsander, Dtsander
      real    mass, upp, pmax, pmin

      real    Lx, x, maxVel, Vel, velX, velY, velZ, h, p1, p2
      
      real lvel(0:2,3), pjump, c(6)
      real curv(1-ONE:imax+ONE,1-ONE:jmax+ONE,1-ONE:kmax+ONE)
      
      character*128 FNAM

      Lx = imax/dxi;
C-------------------------
C
C-------------------------
C      write(FNAM, "('phiS_', I0, '.vtk')") isander
C      open (25,file=FNAM)
C      write(25,"(A)") '# vtk DataFile Version 3.0'
C      write(25,"(A,I5)") 'ZONE', isander
C      write(25,"(A)") 'ASCII'
C      write(25,"(A)") 'DATASET STRUCTURED_POINTS'
C      write(25,"(A,3E13.5)") 'ORIGIN', 0.5/dxi, 0.5/dyi, 0.5/dzi
C      write(25,"(A,3E12.5)") 'SPACING', 1./dxi, 1./dyi, 1./dzi
C      write(25,"(A,3I5)") 'DIMENSIONS', imax, jmax, kmax
C      write(25,"(A,I10)") 'POINT_DATA', (imax)*(jmax)*(kmax)
C-------------------------
C  write Level-Set
C-------------------------
C      write(25,"(A)") 'SCALARS Phi float 1'
C      write(25,"(A)") 'LOOKUP_TABLE default'
C      do k=1,kmax
C        do j=1,jmax
C	  do i=1,imax
C	    write(25,"(E15.5)") Phi(i,j,k)
C	  enddo
C        enddo
C      enddo
      
C-------------------------
C  write vel. vectors
C-------------------------
C      write(25,"(A)") 'VECTORS vel float'
      
C        do k=1,kmax
C          do j=1,jmax
C	    do i=1,imax
C	      write(25,"(3E15.5)")
C     7  	0.5*(Unew(i-1,j,k) + Unew(i,j,k)),
C     8  	0.5*(Vnew(i,j-1,k) + Vnew(i,j,k)),
C     9  	0.5*(Wnew(i,j,k-1) + Wnew(i,j,k))
C	    enddo
C          enddo
C        enddo
C      close(25)

C----------------------------------------------
C  VTK output from guido
C----------------------------------------------

	write(FNAM, "('phi_', I0, '.vtk')") isander
	open (88,file=FNAM)
	write(88,"(A)") '# vtk DataFile Version 3.0'
	write(88,"(a)") 'Velocities and position data'
	write(88,"(a)") 'ASCII'
	write(88,"(a)") 'DATASET RECTILINEAR_GRID'
	write(88,"(a,x,i3,x,i3,x,i3)") 'DIMENSIONS',i1,j1,k1
	write(88,"(a,x,i3,x,a)") 'X_COORDINATES',i1,'float'
        write(88,"(10000E15.5)") (i/dxi, i=0,imax)
        write(88,"(a,x,i3,x,a)") 'Y_COORDINATES',j1,'float'
	write(88,"(10000E15.5)") (j/dyi, j=0,jmax)
	write(88,"(a,x,i3,x,a)") 'Z_COORDINATES',k1,'float'
	write(88,"(10000E15.5)") (k/dzi, k=0,kmax)

C	write(88,"(a,x,i)") 'POINT_DATA', imax*jmax*kmax
	write(88,"(a,x,i)") 'CELL_DATA', imax*jmax*kmax

C  Write level set function

	write(88,"(a,x,a,x,a)") 'SCALARS', 'level_set', 'float'
	write(88,"(a)") 'LOOKUP_TABLE ls_table'
	do k=1,kmax
	  do j=1,jmax
	    do i=1,imax
	      write(88,"(E15.5)") Phi(i,j,k)
	    enddo
	  enddo
	enddo

C  Write pressure

	if (WRITE_PRES.eq.'yes') then
	  write(88,"(a,x,a,x,a)") 'SCALARS', 'pressure', 'float'
	  write(88,"(a)") 'LOOKUP_TABLE pressure_table'
	  do k=1,kmax
	    do j=1,jmax
	      do i=1,imax
		write(88,"(E15.5)") p(i,j,k)
	      enddo
	    enddo
	  enddo
	endif

C  Write unsmoothed curvature

	if (WRITE_CURV.eq.'yes') then
	  call comp_curv_h_new(Phi, dxi, dyi, dzi, curv)

	  write(88,"(a,x,a,x,a)") 'SCALARS', 'curvature_unsmoothed', 'float'
	  write(88,"(a)") 'LOOKUP_TABLE curv_unsmooth_table'
	  do k=1,kmax
	    do j=1,jmax
	      do i=1,imax
		write(88,"(E15.5)") curv(i,j,k)
	      enddo
	    enddo
	  enddo

C  Write smoothed curvature

	  call smooth_curv(Phi, curv, NUM_SMOOTH)

	  write(88,"(a,x,a,x,a)") 'SCALARS', 'curvature_smoothed', 'float'
	  write(88,"(a)") 'LOOKUP_TABLE curv_smooth_table'
	  do k=1,kmax
	    do j=1,jmax
	      do i=1,imax
		write(88,"(E15.5)") curv(i,j,k)
	      enddo
	    enddo
	  enddo
	endif

C  Write velocity vectors

	write(88,"(A)") 'VECTORS velocity float'
      
        do k=1,kmax
          do j=1,jmax
	    do i=1,imax
	      write(88,"(3E15.5)")
     7  	0.5*(Unew(i-1,j,k) + Unew(i,j,k)),
     8  	0.5*(Vnew(i,j-1,k) + Vnew(i,j,k)),
     9  	0.5*(Wnew(i,j,k-1) + Wnew(i,j,k))
	    enddo
          enddo
        enddo
      close(88)

C---------------------------------------------------------
C  Write new file ('maxVel.txt') with maximum velocity for Laplace test.
C---------------------------------------------------------
  
      if (WRITE_MAX_VEL.eq.'yes') then
	Vel = 0.
	maxVel = 0.
        pmax = 0.
	pmin = 0.
 
	do k=1,k1
	  do j=1,j1
	    do i=1,i1
	      velX = 0.5*(unew(i,j,k) + unew(i-1,j,k))
	      velY = 0.5*(vnew(i,j,k) + vnew(i-1,j,k))
	      velZ = 0.5*(wnew(i,j,k) + wnew(i-1,j,k))
	      Vel = sqrt(velX**2. + velY**2. + velZ**2.)
	      maxVel = max(maxVel,Vel)

	      pmax = max(pmax, p(i,j,k))
	      pmin = min(pmin, p(i,j,k))

	    enddo
	  enddo
	enddo

	open(297,file='maxVel.txt',position='append')
	write(297,"(3E15.5)") time, maxVel, abs(pmax-pmin-730.)/730.
      endif

C-------------------------------------------------------------
C  Write new file ('riseVel.txt') with rise velocity for rising bubble test.
C-------------------------------------------------------------

      if (WRITE_RISE_VEL.eq.'yes') then
C	call comp_c(c)
     
C	open(314,file='riseVel.txt', position='append')
C	write(314,"(E15.5, E15.5)") time, c(6)

C-----------------------

	do k=1,kmax
	  if (Phi(imax/2.,3,k).lt.0. .AND. Phi(imax/2.,3,k+1).gt.0.) then
	    p1 = (k-0.5)/dzi
	    p2 = Phi(imax/2.,3,k)/dzi/(Phi(imax/2.,3,k)-Phi(imax/2.,3,k+1))
	    h =  p1 + p2
	  endif
	enddo
	
	open(314,file='height.dat', position='append')
	write(314,"(E15.5,x, E15.9)") time, h
 
      endif

      return
      end
