
#include <iostream>
#include <stdlib.h> 
#include <stdio.h> 
#include <math.h>
#include <string>
#include <sstream>
#include <fstream>
using namespace std;
class coordinate
{
public:
  double x1,x2,x3;
  coordinate(double xx1=0, double xx2=0, double xx3=0){x1=xx1;x2=xx2;x3=xx3;}
};
class vector
{
public:
  double u1,u2,u3;
  vector(double uu1=0, double uu2=0, double uu3=0){u1=uu1;u2=uu2;u3=uu3;}
};
/********************************************************************************/
/*  Function to do the time-stepping sequence from start to end                 */
/*  											*/
/*  Programmer	: Duncan van der Heul       						*/
/*  Date	: 10-03-2013       							*/
/*  Update	:        								*/
/********************************************************************************/
/* Notes:										*/
/*  The magnitude, centroid and velocity of the volume enclosed by the 		*/
/*  interface are computed and collected and written to file			*/
/********************************************************************************/
void analyse_interface_properties(

	
      double ***u_1_velocity_new, 	// velocity field at new time level x1 direction
      double ***u_2_velocity_new, 	// velocity field at new time level x2 direction
      double ***u_3_velocity_new,	// velocity field at new time level x3 direction
      int number_primary_cells_i,	// number of primary (pressure) cells in x1 direction
      int number_primary_cells_j,	// number of primary (pressure) cells in x2 direction
      int number_primary_cells_k,	// number of primary (pressure) cells in x3 direction
      double mesh_width_x1,		// grid spacing in x1 direction (uniform)
      double mesh_width_x2,		// grid spacing in x2 direction (uniform)
      double mesh_width_x3		// grid spacing in x3 direction (uniform)
	
	
	coordinate volume_centroid;  		/* centroid of the volum enclosed by the interface */
	vector velocity_centroid;		/* velocity of the volume enclosed by the interface */
	double enclosed_volume=0;		/* magnitude of the volume enclosed by the interface */
       static ofstream interface_details; 	/* output stream for details of the interface */
	
	/* compute centroid of the enclosed volume */
	/* and compute the velocity of the enclosed volume */
	/* by weighting the coordinates of the cell center and the velocity at the  */
	/* cell center by the volume of fluid 					   */
	
	
	for(i_index=1;i_index<number_primary_cells_i+1;i_index++)
  	{
      		x1_coordinate_cell_center=(i_index-0.5)*mesh_width_x1;
		
		for(j_index=1;j_index<number_primary_cells_j+1;j_index++)
      		{
     			x2_coordinate_cell_center=(j_index-0.5)*mesh_width_x2;
			
	  		for(k_index=1;k_index<number_primary_cells_k+1;k_index++)
	  		{
     				x3_coordinate_cell_center=(k_index-0.5)*mesh_width_x3;
				
				enclosed_volume+=(1-volume_of_fluid_[i_index][j_index][k_index]);
				volume_centroid.x1+= (1-volume_of_fluid_[i_index][j_index][k_index])*
							x1_coordinate_cell_center;
				volume_centroid.x2+= (1-volume_of_fluid_[i_index][j_index][k_index])*
							x2_coordinate_cell_center;
				volume_centroid.x3+= (1-volume_of_fluid_[i_index][j_index][k_index])*
							x2_coordinate_cell_center;
				velocity_centroid.u1+=(1-volume_of_fluid_[i_index][j_index][k_index])*
							0.5*(u_1_velocity_new[i_index-1][j_index][k_index]+
								u_1_velocity_new[i_index][j_index][k_index]);
				velocity_centroid.u2+=(1-volume_of_fluid_[i_index][j_index-1][k_index])*
							0.5*(u_2_velocity_new[i_index][j_index][k_index]+
								u_2_velocity_new[i_index-1][j_index][k_index]);
				velocity_centroid.u3+=(1-volume_of_fluid_[i_index][j_index][k_index])*
							0.5*(u_3_velocity_new[i_index][j_index][k_index-1]+
								u_3_velocity_new[i_index][j_index][k_index]);
  
	  		}  
  
      		}  
     
  	} 
  	
  	/* scale the sum of all components and coordinates by the enclosed volume */
  	
  	volume_centroid.x1=volume_centroid.x1/enclosed_volume;
 	volume_centroid.x2=volume_centroid.x2/enclosed_volume;
 	volume_centroid.x3=volume_centroid.x3/enclosed_volume;
	
	velocity_centroid.u1=velocity_centroid.u1/enclosed_volume;
	velocity_centroid.u1=velocity_centroid.u2/enclosed_volume;
	velocity_centroid.u1=velocity_centroid.u3/enclosed_volume;
	
	
	/* handle the file to which the data have to be written */
	
	/* if the file is not open, open it and write the header */
	
	if(!interface_details.is_open())
	{
		if(!interface_details.open("interface_details.csv", ios::out | ios::app ))
		{
			
		cout<< " file to write details of the interface \n";
		cout<< " can not be opened. In function         \n";
		cout<< " analyse_interface_properties line 115  \n";
		exit(1);
		}
		
		interface_details
	}
